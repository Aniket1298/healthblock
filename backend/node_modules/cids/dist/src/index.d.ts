export = CID;
/**
 * @typedef {Object} SerializedCID
 * @property {string} codec
 * @property {number} version
 * @property {Uint8Array} hash
 */
/**
 * @typedef {0|1} CIDVersion
 * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode
 */
/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 *
 * @class CID
 */
declare class CID {
    /**
     * Test if the given input is a valid CID object.
     * Throws if it is not.
     *
     * @param {any} other - The other CID.
     * @returns {void}
     */
    static validateCID(other: any): void;
    /**
     * Check if object is a CID instance
     *
     * @param {any} value
     * @returns {value is CID}
     */
    static isCID(value: any): value is import(".");
    /**
     * Create a new CID.
     *
     * The algorithm for argument input is roughly:
     * ```
     * if (cid)
     *   -> create a copy
     * else if (str)
     *   if (1st char is on multibase table) -> CID String
     *   else -> bs58 encoded multihash
     * else if (Uint8Array)
     *   if (1st byte is 0 or 1) -> CID
     *   else -> multihash
     * else if (Number)
     *   -> construct CID by parts
     * ```
     *
     * @param {CIDVersion | string | Uint8Array | CID} version
     * @param {string|number} [codec]
     * @param {Uint8Array} [multihash]
     * @param {string} [multibaseName]
     *
     * @example
     * new CID(<version>, <codec>, <multihash>, <multibaseName>)
     * new CID(<cidStr>)
     * new CID(<cid.bytes>)
     * new CID(<multihash>)
     * new CID(<bs58 encoded multihash>)
     * new CID(<cid>)
     */
    constructor(version: CIDVersion | string | Uint8Array | CID, codec?: string | number | undefined, multihash?: Uint8Array | undefined, multibaseName?: string | undefined);
    version: any;
    codec: any;
    multihash: any;
    multibaseName: any;
    /**
     * The CID as a `Uint8Array`
     *
     * @returns {Uint8Array}
     *
     */
    get bytes(): Uint8Array;
    /**
     * The prefix of the CID.
     *
     * @returns {Uint8Array}
     */
    get prefix(): Uint8Array;
    /**
     * The codec of the CID in its number form.
     *
     * @returns {number}
     */
    get code(): number;
    /**
     * Convert to a CID of version `0`.
     *
     * @returns {CID}
     */
    toV0(): CID;
    /**
     * Convert to a CID of version `1`.
     *
     * @returns {CID}
     */
    toV1(): CID;
    /**
     * Encode the CID into a string.
     *
     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
     * @returns {string}
     */
    toBaseEncodedString(base?: "base58btc" | "identity" | "\0" | "0" | "7" | "9" | "f" | "F" | "v" | "V" | "t" | "T" | "b" | "B" | "c" | "C" | "h" | "k" | "K" | "z" | "Z" | "m" | "M" | "u" | "U" | "base2" | "base8" | "base10" | "base16" | "base16upper" | "base32hex" | "base32hexupper" | "base32hexpad" | "base32hexpadupper" | "base32" | "base32upper" | "base32pad" | "base32padupper" | "base32z" | "base36" | "base36upper" | "base58flickr" | "base64" | "base64pad" | "base64url" | "base64urlpad" | undefined): string;
    /**
     * Encode the CID into a string.
     *
     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
     * @returns {string}
     */
    toString(base?: "base58btc" | "identity" | "\0" | "0" | "7" | "9" | "f" | "F" | "v" | "V" | "t" | "T" | "b" | "B" | "c" | "C" | "h" | "k" | "K" | "z" | "Z" | "m" | "M" | "u" | "U" | "base2" | "base8" | "base10" | "base16" | "base16upper" | "base32hex" | "base32hexupper" | "base32hexpad" | "base32hexpadupper" | "base32" | "base32upper" | "base32pad" | "base32padupper" | "base32z" | "base36" | "base36upper" | "base58flickr" | "base64" | "base64pad" | "base64url" | "base64urlpad" | undefined): string;
    /**
     * Serialize to a plain object.
     *
     * @returns {SerializedCID}
     */
    toJSON(): SerializedCID;
    /**
     * Compare equality with another CID.
     *
     * @param {CID} other
     * @returns {boolean}
     */
    equals(other: CID): boolean;
}
declare namespace CID {
    export { codecs, SerializedCID, CIDVersion, BaseNameOrCode };
}
type SerializedCID = {
    codec: string;
    version: number;
    hash: Uint8Array;
};
type CIDVersion = 0 | 1;
declare const codecs: Record<import("multicodec/src/generated-types").CodecName, import("multicodec/src/generated-types").CodecNumber>;
type BaseNameOrCode = "base58btc" | "identity" | "\0" | "0" | "7" | "9" | "f" | "F" | "v" | "V" | "t" | "T" | "b" | "B" | "c" | "C" | "h" | "k" | "K" | "z" | "Z" | "m" | "M" | "u" | "U" | "base2" | "base8" | "base10" | "base16" | "base16upper" | "base32hex" | "base32hexupper" | "base32hexpad" | "base32hexpadupper" | "base32" | "base32upper" | "base32pad" | "base32padupper" | "base32z" | "base36" | "base36upper" | "base58flickr" | "base64" | "base64pad" | "base64url" | "base64urlpad";
//# sourceMappingURL=index.d.ts.map